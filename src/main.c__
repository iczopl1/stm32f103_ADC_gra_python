#include "stm32f103xb.h"
//#include "ftoa.h"
/*
	LCD PIN CONFIGURATION

	D4 - PA0
	D5 - PA1
	D6 - PA2
	D7 - PA3

	RS -PA4
	E - PA5
	RW - GND - need delay steering

*/


// C program for implementation of ftoa()


#include <stdlib.h>


// LCD RS and E macros
#define RS_1 GPIOA->ODR |= GPIO_ODR_ODR4;
#define RS_0 GPIOA->ODR &= ~GPIO_ODR_ODR4;
#define  E_1 GPIOA->ODR |= GPIO_ODR_ODR5;
#define  E_0 GPIOA->ODR &= ~GPIO_ODR_ODR5;

void pll_init(void);

volatile uint16_t adc; // tablicja dla ADC
volatile float wynik; // tablica przeliczonych wyników
volatile uint32_t delay_var;


void SysTick_Handler(void)
{
		if (delay_var) delay_var--;
}
void delay_ms(uint32_t value)
{
	delay_var = value;
	while(delay_var);
}
void lcd_gpio_init()
{
	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;

	//GPIOA0-GPIOA4 as P-P
	GPIOA->CRL &= ~GPIO_CRL_CNF0_0;
	GPIOA->CRL &= ~GPIO_CRL_CNF1_0;
	GPIOA->CRL &= ~GPIO_CRL_CNF2_0;
	GPIOA->CRL &= ~GPIO_CRL_CNF3_0;
	GPIOA->CRL &= ~GPIO_CRL_CNF4_0;
	GPIOA->CRL &= ~GPIO_CRL_CNF5_0;


	GPIOA->CRL |= GPIO_CRL_MODE0_1;
	GPIOA->CRL |= GPIO_CRL_MODE1_1;
	GPIOA->CRL |= GPIO_CRL_MODE2_1;
	GPIOA->CRL |= GPIO_CRL_MODE3_1;
	GPIOA->CRL |= GPIO_CRL_MODE4_1;
	GPIOA->CRL |= GPIO_CRL_MODE5_1;

}

void lcd_send_command(char cmd)
{
	GPIOA->ODR&=~0xF; //clear

    RS_0; 		// RS = 0, this will be send a command
    E_1;
    delay_ms(5);
    GPIOA->ODR|=(cmd>>4) & 0xf;
    E_0;		// sampling LSB
    GPIOA->ODR&=~0xF; //clear
    E_1;
    delay_ms(5);
    GPIOA->ODR |= cmd&0xf;
    E_0;
    RS_0;
    GPIOA->ODR&=~0xF; //clear
}
void lcd_send_data(char data)
{
	GPIOA->ODR&=~0xF; //clear

    RS_1; 		// RS = 0, this will be send a data
    E_1;
    delay_ms(1);
    GPIOA->ODR|=(data>>4) & 0xf; // because p0.16 is DB0, p.017 is DB1 etc etc, that we move cmd left 16 times;
    E_0;
    delay_ms(1);
    GPIOA->ODR&=~0xF; //clear
    E_1;
    GPIOA->ODR |= data&0xf;
    E_0;
    delay_ms(1);
    RS_0;
}
void lcd_write_string(const char* str)
{
	int i;
	for (i = 0; str[i] != 0; i++)
	{
		lcd_send_data(str[i]);
	}
}
void lcd_set_address(char addr)
{
	lcd_send_command(0x80 | addr);
}
void ADC1_2_IRQHandler(void)
{
	if (ADC1->SR & ADC_SR_EOC)
	{
	adc=ADC1->DR;
	}
}
void pll_init(void)
{
	// HSE ON
	RCC->CR|=RCC_CR_HSEON;
	// wait for HSE ON
	while(!(RCC->CR & RCC_CR_HSERDY));
	//PLLXTPRE = 0, HSE clock not divided
	// HSE is source for PLL
	RCC->CFGR|=RCC_CFGR_PLLSRC;
	// PLL multiplication factor Crystal 8MHz*_9_=72MHz
	RCC->CFGR|=RCC_CFGR_PLLMULL9;
	//PLL ON
	RCC->CR|=RCC_CR_PLLON;
	// Wait for PLL ready
	while(!(RCC->CR & RCC_CR_PLLRDY));
	// PLL if configured and WORK
	// Configure dividers to buses
	// AHB prescaler = 1 , HPRE = 0;
	// APB1 prescaler: 72MHz/2 = 32 (this is max)
	RCC->CFGR|=RCC_CFGR_PPRE1_DIV2;
	//APB2 prescaler = 1: PPRE2=0
	// FLASH latency config, Two wait states
	FLASH->ACR|=FLASH_ACR_LATENCY_1;
	// SWITH SYSTEM CLOCK to PLL
	RCC->CFGR|=RCC_CFGR_SW_1;
	// wait for SYSTEM CLOCK swithed
	while(!(RCC->CFGR & RCC_CFGR_SWS_1));
}


int main(void){

	RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;	// enable clock to C port
	RCC->APB2ENR |= RCC_APB2ENR_IOPBEN; // zegar do portu B
	GPIOC->CRH |= GPIO_CRH_MODE13_1;	// C13 as 2MHz, output


	// konfiguracja timera TIM3
	RCC->APB1ENR |= RCC_APB1ENR_TIM3EN; 			// włączenie zegara
	TIM3->ARR=72-1;
	TIM3->PSC=10000-1;  								//preskaler
	TIM3-> CR2 |= TIM_CR2_MMS_1; 					// właczenie TRG w ADC
	TIM3->EGR |= TIM_EGR_UG;						// Generowanie TRGO
	TIM3->CR1 |= TIM_CR1_CEN;

	// PA6 as ADC input
	GPIOA->CRL &=~GPIO_CRL_CNF6_Msk;

	// konfiguracja ADC1
	RCC->APB2ENR |= RCC_APB2ENR_ADC1EN; 			// zegar dla ADC1
	ADC1 -> CR2 |= ADC_CR2_EXTSEL_2;				//ADC1 konwersja od Timer3 TRGO
	ADC1 -> CR2 |= ADC_CR2_EXTTRIG;	// zezwolenie na zewnetrzne wyzwalanie konwersji
	ADC1-> SQR3 |= ADC_SQR3_SQ1_1|ADC_SQR3_SQ1_2; 					// 6 channel
	ADC1->CR1 |=ADC_CR1_EOCIE; 						// wlacza przerwanie od konca konwersji
	NVIC_EnableIRQ(ADC1_2_IRQn);
	ADC1->CR2 |= ADC_CR2_ADON;

//	lcd_gpio_init();
	pll_init(); 								// core clocked by 72MHz
	SysTick_Config(72000000/1000);
/*

	lcd_send_command(0x33);
	lcd_send_command(0x32);
	lcd_send_command(0x28);
	lcd_send_command(0x08);
	lcd_send_command(0x01);
	lcd_send_command(0x0C);
	//lcd_send_command(0x07);

*/

	// przycisk na pb6

		GPIOB->CRL &= ~GPIO_CRL_CNF6_0;
		GPIOB->CRL |= GPIO_CRL_CNF6_1;
		GPIOB->ODR |= GPIO_ODR_ODR6;
		GPIOB->CRL &= ~GPIO_CRL_MODE6_Msk;




	while(1)
	{
/*
		double a=3.3/4095;
		wynik=(-111*(0.2-(2*(adc*a))));//wzor ktory przeliczna na ciśnienie
			// powinno być 111.11111111 ale zawiesza stm
*/

		char string[10];
		itoa(adc, string, 10);

/*		lcd_set_address(0x00);
		lcd_write_string(string);
		lcd_set_address(0x06);
		lcd_write_string(" kPa");
		delay_ms(1000);*/


		// sprawdzanie stanu na pb6

			if	(GPIOB->IDR & GPIO_IDR_IDR6	)

				GPIOC->ODR &= ~GPIO_ODR_ODR13;
			else
				GPIOC->ODR |= GPIO_ODR_ODR13;




/*		GPIOC->ODR |= GPIO_ODR_ODR13;
		delay_ms(1000);
		GPIOC->ODR &= ~GPIO_ODR_ODR13;
		delay_ms(1000);*/

	} /* while(1) */
} /* main */



